"""tumor_reg_summary -- summarize NAACCR tumor registry file

Capture statistics useful for synthesizing data.

Usage:

  tumor_reg_summary naaccr_ddict/record_layout.csv tr.db naaccr_file

where `record_layout.csv` is generated by `naaccr_ddict/scrape.py`.


Static Typing
~~~~~~~~~~~~~

Check with `mypy --strict`.

"""

from contextlib import contextmanager
from itertools import islice
from pathlib import Path as Path_T  # use type only, per ocap discipline
from sys import stderr  # ocap exception for logging
from typing import (
    Any,
    Callable, Iterable, Iterator,
    List, NamedTuple, Tuple,
    TextIO,
    cast,
)
import csv
import sqlite3

Chunk = List[Tuple[int, str]]


def main(argv: List[str], cwd: Path_T,
         connect: Callable[[str], sqlite3.Connection]) -> None:
    [layout, dbfn, naaccr_file] = argv[1:4]

    db = connect(str(dbfn))
    tr = Registry.make(db, cwd / layout)
    tr.load_eav(cwd / naaccr_file)


def _log(*args: Any) -> None:
    print(*args, file=stderr)


class Item(NamedTuple):
    """NAACCR Item, i.e. a field
    """

    start: int
    end: int
    length: int
    item: int
    name: str
    xmlId: str
    parentTag: str
    section: str
    note: str


class Registry(object):
    """
    >>> proto = Item(1, 2, 1, 10, 'Size', 'size', 'Tumor', 'C', '')
    >>> layout = [proto, proto._replace(xmlId='weight', length=3)]

    >>> tr = Registry(sqlite3.connect(':memory:'), layout)
    >>> tr.insert_dml()
    'insert into tumors (size, weight) values(?, ?)'
    """
    def __init__(self, conn: sqlite3.Connection, layout: List['Item'],
                 table_name: str = 'tumors') -> None:
        self.__conn = conn
        self.layout = layout
        self.table_name = table_name

    @classmethod
    def make(cls, conn: sqlite3.Connection, layout: Path_T,
             max_length: int = 10,
             table_name: str = 'tumors') -> 'Registry':
        eav_ddl = '''
        create table {0}_eav (tumorid int, item int, value text)
        '''.format(table_name)
        conn.cursor().execute(eav_ddl)
        _log('created {0}'.format(table_name))
        items = [it for it in cls.load_layout(layout.open())
                 if it.length <= max_length]
        ddl = cls.create_ddl(table_name, items)
        conn.cursor().execute(ddl)
        _log('created: {0} with {1} columns'.format(table_name, len(items)))
        return cls(conn, items)

    def load_eav(self, tumors: Path_T) -> int:
        insert_stmt = '''
        insert into {table}_eav (tumorid, item, value) values (?, ?, ?)
        '''.format(table=self.table_name)
        qty = 0
        with txn(self.__conn) as work:
            for lines in self._file_chunks(tumors):
                records = [
                    (ix, it.item, chars)
                    for ix, line in lines
                    for it in self.layout
                    for chars in [line[it.start - 1:it.end].strip()]
                    if chars
                ]
                work.executemany(insert_stmt, records)
                qty += len(records)
                last_tumorid, _ = lines[-1]
                _log('tumor {id}: records inserted += {n} = {qty}'.format(
                    id=last_tumorid, n=len(records), qty=qty))

        return qty

    def load_file(self, tumors: Path_T) -> int:
        insert_stmt = self.insert_dml()

        qty = 0
        with txn(self.__conn) as work:
            for lines in self._file_chunks(tumors):
                records = [
                    tuple([line[it.start - 1:it.end]
                           for it in self.layout])
                    for ix, line in lines
                ]
                work.executemany(insert_stmt, records)
                qty += len(records)
                _log('records inserted += {n} = {qty}'.format(
                    n=len(records), qty=qty))

        return qty

    def _file_chunks(self, tumors: Path_T,
                     chunk_size: int = 4096) -> Iterable[Chunk]:
        with cast(TextIO, tumors.open(mode='r')) as fp:  # typeshed/issues/2911
            lines = enumerate(fp)
            while True:
                chunk = list(islice(lines, chunk_size))
                if not chunk:
                    break
                yield chunk

    @classmethod
    def load_layout(cls, lines: Iterator[str]) -> Iterator[Item]:
        for rec in csv.DictReader(lines):
            yield Item(start=int(rec.pop('start')),
                       end=int(rec.pop('end')),
                       length=int(rec.pop('length')),
                       item=int(rec.pop('item')),
                       **rec)

    @classmethod
    def create_ddl(cls, name: str, items: Iterable['Item']) -> str:
        return 'create table {name} (\n{coldefs})\n'.format(
            name=name,
            coldefs=',\n'.join('  {0.xmlId} varchar({0.length})'.format(it)
                               for it in items),
        )

    def insert_dml(self) -> str:
        return 'insert into {table} ({colnames}) values({params})'.format(
            table=self.table_name,
            colnames=', '.join(it.xmlId for it in self.layout),
            params=', '.join(['?'] * len(self.layout))
        )


@contextmanager
def txn(conn: sqlite3.Connection) -> Iterator[sqlite3.Cursor]:
    cur = conn.cursor()
    try:
        yield cur
    except:  # noqa
        conn.rollback()
        raise
    else:
        conn.commit()


if __name__ == '__main__':
    def _script() -> None:
        # Access ambient authority only when invoked as script,
        # as a form of ocap discipline.
        from sys import argv
        from pathlib import Path
        from sqlite3 import connect

        main(argv[:], Path('.'), lambda f: connect(f))

    _script()
