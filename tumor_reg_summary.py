"""tumor_reg_summary -- summarize NAACCR tumor registry file

Capture statistics useful for synthesizing data.

Usage:

  tumor_reg_summary naaccr_ddict/record_layout.csv tr.db naaccr_file

where `record_layout.csv` is generated by `naaccr_ddict/scrape.py`.


Static Typing
~~~~~~~~~~~~~

Check with `mypy --strict`.

"""

from contextlib import contextmanager
from itertools import islice
from pathlib import Path as Path_T  # use type only, per ocap discipline
from sys import stderr  # ocap exception for logging
from typing import Any, Callable, Iterable, Iterator, List, NamedTuple
import csv
import sqlite3


def main(argv: List[str], cwd: Path_T,
         connect: Callable[[str], sqlite3.Connection]) -> None:
    [layout, dbfn, naaccr_file] = argv[1:4]

    db = connect(str(dbfn))
    tr = Registry.make(db, cwd / layout)
    tr.load_file(cwd / naaccr_file)


def _log(*args: Any) -> None:
    print(*args, file=stderr)


class Item(NamedTuple):
    """NAACCR Item, i.e. a field
    """

    start: int
    end: int
    length: int
    item: int
    name: str
    xmlId: str
    parentTag: str
    section: str
    note: str


class Registry(object):
    """
    >>> proto = Item(1, 2, 1, 10, 'Size', 'size', 'Tumor', 'C', '')
    >>> layout = [proto, proto._replace(xmlId='weight', length=3)]

    >>> tr = Registry(sqlite3.connect(':memory:'), layout)
    >>> tr.insert_dml()
    'insert into tumors (size, weight) values(?, ?)'
    """
    def __init__(self, conn: sqlite3.Connection, layout: List['Item'],
                 table_name: str = 'tumors') -> None:
        self.__conn = conn
        self.layout = layout
        self.table_name = table_name

    @classmethod
    def make(cls, conn: sqlite3.Connection, layout: Path_T,
             table_name: str = 'tumors') -> 'Registry':
        items = list(cls.load_layout(layout.open()))
        ddl = cls.create_ddl(table_name, items)
        conn.cursor().execute(ddl)
        _log('created: {0} with {1} columns'.format(table_name, len(items)))
        return cls(conn, items)

    def load_file(self, tumors: Path_T,
                  chunk_size: int = 4096) -> int:
        insert_stmt = self.insert_dml()

        qty = 0
        with tumors.open() as fp:
            with txn(self.__conn) as work:
                while True:
                    lines = list(islice(fp, chunk_size))
                    if not lines:
                        break
                    records = [
                        tuple([line[it.start - 1:it.end]
                               for it in self.layout])
                        for line in lines
                    ]
                    work.executemany(insert_stmt, records)
                    qty += len(records)
                    _log('records inserted += {n} = {qty}'.format(
                        n=len(records), qty=qty))

        return qty

    @classmethod
    def load_layout(cls, lines: Iterator[str]) -> Iterator[Item]:
        for rec in csv.DictReader(lines):
            yield Item(start=int(rec.pop('start')),
                       end=int(rec.pop('end')),
                       length=int(rec.pop('length')),
                       item=int(rec.pop('item')),
                       **rec)

    @classmethod
    def create_ddl(cls, name: str, items: Iterable['Item']) -> str:
        return 'create table {name} (\n{coldefs})\n'.format(
            name=name,
            coldefs=',\n'.join('  {0.xmlId} varchar({0.length})'.format(it)
                               for it in items),
        )

    def insert_dml(self) -> str:
        return 'insert into {table} ({colnames}) values({params})'.format(
            table=self.table_name,
            colnames=', '.join(it.xmlId for it in self.layout),
            params=', '.join(['?'] * len(self.layout))
        )


@contextmanager
def txn(conn: sqlite3.Connection) -> Iterator[sqlite3.Cursor]:
    cur = conn.cursor()
    try:
        yield cur
    except:  # noqa
        conn.rollback()
        raise
    else:
        conn.commit()


if __name__ == '__main__':
    def _script() -> None:
        # Access ambient authority only when invoked as script,
        # as a form of ocap discipline.
        from sys import argv
        from pathlib import Path
        from sqlite3 import connect

        main(argv[:], Path('.'), lambda f: connect(f))

    _script()
